<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solfeggio Training</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        margin: 0;

        flex-direction: column;
        height: 100vh;
      }

      /* center the main section in the page */
      .main {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-grow: 1;
      }

      header {
        background-color: #333;
        color: white;
        text-align: center;
        padding: 10px 0;
        margin-bottom: 20px;
      }

      header h1 {
        margin: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      div {
        margin-bottom: 15px;
        text-align: center;
      }

      label {
        display: block;
        margin-bottom: 5px;
      }

      input {
        padding: 8px;
        box-sizing: border-box;
      }

      button {
        padding: 10px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
      }

      button:hover {
        background-color: #45a049;
      }

      #restartBtn {
        background-color: #f44336;
      }

      #restartBtn:hover {
        background-color: #d32f2f;
      }
    </style>
    <script src="http://unpkg.com/tone"></script>
    <script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>
  </head>
  <body>
    <header>
      <h1>Solfeggio</h1>
    </header>

    <section class="main">
      <div>
        <label for="notesInput">Notes:</label>
        <input
          type="text"
          value="C, E, G"
          id="notesInput"
          placeholder="Enter notes"
        />
      </div>

      <div>
        <label for="notesCombination">Note Combinations:</label>
        <input
          type="number"
          value="2"
          id="notesCombination"
          placeholder="How many note combinations"
        />
      </div>

      <div>
        <label for="transposeCountInput">Transpose Count:</label>
        <input
          type="number"
          value="2"
          id="transposeCountInput"
          placeholder="Enter transpose count"
        />
      </div>

      <input type="hidden" id="pause" value="" />
      <button id="playBtn" onclick="startTraining()">Start Training</button>
      <button id="restartBtn" onclick="window.location.reload()">
        Restart
      </button>
    </section>
    <script>
      document.getElementById('playBtn').addEventListener('click', () => {
        const paused = document.getElementById('pause')
        const trainingButton = document.getElementById('playBtn')

        if (paused.value === '') {
          paused.value = 'false'
          trainingButton.textContent = 'pause'
        } else if (paused.value !== 'true') {
          paused.value = 'true'
          trainingButton.textContent = 'Resume'
        } else {
          paused.value = 'false'
          trainingButton.textContent = 'Pause'
        }
      })
    </script>

    <!-- utils -->
    <script>
      const solfegePhonetic = {
        C: 'doh',
        // 'C#': 'di',
        D: 'ray',
        // 'D#': 'ri',
        E: 'mee',
        F: 'fah',
        // 'F#': 'fi',
        G: 'soh',
        // 'G#': 'si',
        A: 'lah',
        // 'A#': 'li',
        B: 'tee',
      }

      const solfeges = Object.values(solfegePhonetic)

      /**
       * @param {number} x
       * @param {number} y
       *
       * @returns {number}
       */
      function getNoBetweenXAndY(x = 3, y = 6) {
        return Math.floor(Math.random() * (y - x + 1) + x)
      }

      /**
       * @param {[string]} notes
       * @param {number} pos
       *
       * @returns {[string]}
       */
      function getNotesPitch(notes, pos = getNoBetweenXAndY()) {
        return notes.map((note) => note + pos)
      }

      /**
       * @param {string} rootNote
       *
       * @returns {[string]}
       */
      function getNoteChord(rootNote) {
        return Tonal.Chord.get(rootNote).notes
      }

      /**
       * @param {String} notes
       * @param {String} key
       * @description Given a note, get the moveable do solfege.
       * e.g in the key of A, the solfege of A is DO, B is RE, C# is MI, etc
       *
       * @returns {[String]}
       */
      function getMoveableDo(note, key) {
        const scale = Tonal.Scale.get(rootNote + ' major').notes
        const rootNoteIndex = scale.indexOf(rootNote)

        const noteIndex = scale.indexOf(note)
        return solfeges[noteIndex]
      }

      /**
       * @param {[String]} notes
       * @param {number} duration: note duration e.g 8th note
       * @description Get the solfege of the note e.g C -> DO
       *
       * @returns {void}
       */
      async function playNotes(notes, duration = '8n') {
        const synth = new Tone.Synth().toDestination()
        for (const note of notes) {
          await sleep(500)
          synth.triggerAttackRelease(note, duration)
        }
      }

      /**
       * @param {[string]} chord
       * @param {string} duration
       *
       * @returns {void}
       */
      function playChord(chord, duration = '2n') {
        const synth = new Tone.PolySynth().toDestination()
        synth.triggerAttackRelease(chord, duration)
      }

      /**
       * @param {[string]} notes
       * @param {number} transposeInterval
       *
       * @returns {[string]}
       */
      function transposeNotes(
        notes,
        transposeInterval = Math.floor(Math.random() * 12) + 1,
      ) {
        return notes.map((note) =>
          Tonal.Note.transpose(note, transposeInterval),
        )
      }

      /**
       * @param {[string]} notes
       * @param {string} pitch
       *
       * @returns {void}
       */
      function pronounceNotesWithPitch(notes, pitch) {
        notes.forEach(async (note, index) => {
          const synth = new Tone.Synth().toDestination()
          synth.triggerAttackRelease(pitch[index], '2n')

          const utterance = new SpeechSynthesisUtterance(
            getMoveableDo(note, notes[0]),
          )
          window.speechSynthesis.speak(utterance)
          await sleep(1000)
        })
      }

      /**
       * @param {number} ms
       */
      function sleep(ms = 1000) {
        return new Promise((resolve) => setTimeout(resolve, ms))
      }
    </script>

    <script>
      /**
       * @param {[string]} notes
       * @param {number} length
       *
       * @returns {[[string]]} allCombinations
       */
      function generateAllNoteCombinations(
        notes,
        length,
        currentCombination = [],
        allCombinations = [],
      ) {
        if (length === 0) {
          // Base case: when the desired length is reached, add the current combination to the result
          allCombinations.push([...currentCombination])
          return
        }

        // Recursively add each note to the current combination and generate combinations for the remaining length
        for (const note of notes) {
          currentCombination.push(note)
          generateAllNoteCombinations(
            notes,
            length - 1,
            currentCombination,
            allCombinations,
          )
          currentCombination.pop() // Backtrack to try the next note
        }
        return allCombinations
      }
    </script>

    <script>
      /**
       * @param {[[string]]} note list
       * @param {[string]} chordNotes
       * @param {[string]} originalNotes
       *
       * @return {[[string]]}
       */
      function createTuneList(list, chordNotes, originalNotes, pitch) {
        list.push(
          playChord.bind(null, getNotesPitch(chordNotes, pitch)),
          sleep,
          playNotes.bind(null, getNotesPitch(originalNotes, pitch)),
          sleep,
        )
        return list
      }

      /**
       * @param {[[string]]} allNoteCombinations
       * @param {number} transposeCount
       *
       * @returns {[[Function]]}
       */
      function buildTrainingNotes(allNoteCombinations, transposeCount) {
        const MIDDLE_PITCH = 4

        const trainingNotes = []
        for (const notes of allNoteCombinations) {
          const list = []
          // push tonic and notes to list
          const originalNotes = [...notes]
          const chordNotes = getNoteChord(originalNotes[0])
          createTuneList(list, chordNotes, originalNotes, MIDDLE_PITCH)

          // transpose the original notes 'transposeCount' times, and add it to the list
          for (let i = 0; i < transposeCount; i++) {
            const transposedNotes = transposeNotes(originalNotes)
            const transposedChordNotes = getNoteChord(transposedNotes[0])
            createTuneList(list, transposedChordNotes, transposedNotes)
          }

          // read out original notes, so the user can check they got it right
          list.push(
            sleep.bind(null, 5000),
            pronounceNotesWithPitch.bind(
              null,
              originalNotes,
              getNotesPitch(originalNotes, MIDDLE_PITCH),
            ),
          )
          trainingNotes.push(list)
        }
        return trainingNotes
      }
    </script>

    <script>
      /**
       * @description Start ear training, the provided notes and the specified no of random transpositions are played
       * after that the original notes are read out, to check if the user can recognize the notes
       */
      function startTraining() {
        const notesInput = document.getElementById('notesInput')

        const notesCombination =
          document.getElementById('notesCombination').value

        const transposeCountInput = document.getElementById(
          'transposeCountInput',
        ).value

        const notes = notesInput.value
          .split(',')
          .map((note) => note.trim().toUpperCase())
          .filter((note) => note >= 'A' && note <= 'G')

        notesInput.value = notes.join(', ')

        // generate all the note combinations
        const allNoteCombinations = generateAllNoteCombinations(
          notes,
          parseInt(notesCombination),
        )
        // build the training notes
        const trainingNotes = buildTrainingNotes(
          allNoteCombinations,
          parseInt(transposeCountInput),
        )

        // free memory
        allNoteCombinations.length = 0
        playTrainingNotes(trainingNotes)
      }

      /**
       * @param {[[Function]]} trainingNotes
       *
       * @returns {void}
       */
      async function playTrainingNotes(trainingNotes) {
        // choose a tune at random from the trainingNotes list and play it, then choose another
        // make sure not to choose the same tune twice in a row
        let set = new Set()
        while (true) {
          // simulate a pause
          if (document.getElementById('pause').value === 'true') {
            await sleep(1000)
            continue
          }

          const tunePos = Math.floor(Math.random() * trainingNotes.length)
          if (set.has(tunePos)) {
            continue
          }
          set.add(tunePos)
          if (set.size === trainingNotes.length) {
            trainingNotes.length = 0
            alert("You've completed the training, you can go again if you want")
            return
          }

          for (const action of trainingNotes[tunePos]) await action()
        }
      }
    </script>
  </body>
</html>
